#背包
0/1背包

给定N个物品，其中第i个物品的体积为Vi，价值为Wi
有一个容积为M的背包，要求选择一些物品放入背包，使得物品总体积不超过M的前提下，物品的价值总和最大


f[i,j]表示前i个物品中选出了总体积为j的物品，物品的最大价值和
f[i,j] = max(f[i-1,j],  //不选第i个物品
             f[i-1, j-Vi] + Wi if j>=Vi)//选第i个物品
             
初值f[0,0] = 0,  其余负无穷
目标max(f[n][j]) (0<=j<=m)


优化版

for (int i=1; i<n+1; i++)
    for (int j=m; j>V[i]; j--) //省略i后必须倒序
        f[j] = max(f[j], f[j - V[i]] + W[i])
int ans = 0;
for (int j=0; j< m+1; j++)
    ans = max(ans, f[j]);
    
上面的状态转移方程实际上上存储了所有阶段的状态
对于每个阶段的状态，我们发现它们都是从上一阶段转移过来的，
所以我们完全没必要存下所有阶段的状态，我们只要保存上一阶段的所有状态和当前阶段的所有状态就行了

但是我们要注意一点，前面已经说了，当前阶段的状态是从上一个阶段转移过来的，如果我们用一维dp数组，
我们还是按顺序转移，即如下所示的转移过程：

for(int i = 1; i <= n; ++i)
{
    for(int j = w[i]; j <= W; ++j)
    {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
} 

现在的转移方式比如转移到了某一时刻，前面都是当前阶段的状态，后面都是上一阶段的状态，
那么很有可能，后面当前阶段的状态就会从前面当前阶段的状态转移过来，即某一物品使用了多次


#完全背包
给定N个物品，其中第i个物品的体积为Vi，价值为Wi，并且无限个
有一个容积为M的背包，要求选择一些物品放入背包，使得物品总体积不超过M的前提下，物品的价值总和最大

f[i,j]表示前i个物品中选出了总体积为j的物品，物品的最大价值和
f[i,j] = max(f[i-1,j],  //不选第i个物品
             f[i, j-Vi] + Wi if j>=Vi)//再选一个第i个物品,此处跟上面i-1不同
    
             
初值f[0,0] = 0,  其余负无穷
目标max(f[n][j]) (0<=j<=m)

for(int i = 1; i <= n; ++i)
{
    for(int j = v[i]; j <= m; j++) //j正序是完全背包
    {
        f[j] = max(f[j], f[j - v[i]] + w[i]);
    }
} 

int ans=0;
for (int j=0; j<m+1; j++)
    ans = max(ans, f[j])

零钱兑换就是完全背包模型
零钱=物品，体积=面值，价值=1，求min（价值）


1499. 满足不等式的最大值
hard 跳过！
