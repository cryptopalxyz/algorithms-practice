算法不复杂，常考，建议多花时间

#Rabin-Karp字符串哈希算法
O(1)得到hash值
问题：
给定长度n的字符串s，长度m的字符串t，
求t是否在s中出现过，即t是否是s的子串
朴素O(MN)
RK算法O(n+m)
思路：
计算s的每个长度是m的子串的hash值，检查是否与t的hash值相同

把字符串看作一个b进制数，计算它对p取模的值

举例：
beta=131, p=2^64
字符串foobar的hash值为(a=1,b=2,f=6,o=15,r=18)
(6*131^5 + 15*131^4 + 15*131^4 + 2*131^2 + 1*131 + 18)  mod 2^64
beta=131,13331等，p为最大质数，冲突概率极小；万一hash值相同，可以再对比一下两个字符串。




#子串，回文，同构


#模式匹配

#KMP算法

#高级搜索算法
剪枝
迭代加深，折半搜索，双向搜索
启发式搜索 A*算法

蛮力搜索
指数型：K pow（n）子集，大体积背包
排列型：n! 全排列，旅行商，N皇后
组合型: n!/(m!(n-m)!) 组合选数

初级搜索搜索：
DFS
BFS
简单的优化：判重
状态空间状态空间，搜索树/图等概念
DFS/BFS对对状态空间的遍历
