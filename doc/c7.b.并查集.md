#并查集

处理不相交集合(disjoint sets)的合并和查询问题->处理分组问题->维护无序二元关系

基本操作
MakeSet(s)
建立新的并查集，包括s个集合，每个集合只有一个元素

UnionSet(x, y)
把元素x和元素y所在的集合合并
要求x和y所在的集合不相交，如果相交则无需合并

Find(x)
找到元素x所在的集合的代表
该操作也可以用于判断两个元素是否位于同一个集合，只要讲它们各自的代表比较一下

内部实现

MakeSet
每个集合是一个树形结构
每个结点只需要保持一个值：它的父节点

最简单的实现是一个int[] fa, fa[x]表示编号x的结点的父节点
根节点fa等于它自己

UnionSet
但是数组难做合并，可以采用树形结构
把第二课树的根指向第一棵树的根

Find
找根，一直循环，当等于自己停止O(N)
小的树往大的指- 启发式合并，也叫按秩合并

#压缩路径
根和子节点之间没有其他结点，所有子节点都指向根，树的深度=1
在find的过程中，顺便做路径压缩

同时采用路径压缩+按秩合并优化的并查集，单次操作的均摊复杂度时O(a(n))
只采用一种是O(log(n))

a(n)阿尔法是反阿克曼函数，比logn增长还要缓慢许多的函数，接近常数
通常为了简便，只是用路径压缩


超市题跳过！
