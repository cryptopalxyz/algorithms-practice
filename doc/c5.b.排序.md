#基于比较的各类排序算法
下界O(NlogN)，不可能更好
非比较

#其他排序算法，适用场景

#第K大数，中位数，逆序对等应用

初级排序
#选择排序
每次从未排序的数据中找最小值，放到已排序序列的末尾

#插入排序
从前到后依次考虑每个未排序数据，在已排序序列中找到合适位置插入

#冒泡排序
不断循环扫描，每次查看相邻的元素，如果逆序，则交换
平均时间复杂度O(N)

#堆排序
是对上面选择排序的优化-利用二叉堆高效的选出最小值
建立一个包含所有N个元素的二叉堆
重复N次从堆中取出最小值，即可得到有序序列
时间复杂度O(NlogN)

void heap_sort(int a[], int n) {
    priority_queue<int> q;
    for (int i =0; i<n; i++) {
        q.push(a[i]);
    }
    for (int i=0; i<n;i++) {
        a[i] = q.top();
        q.pop();
    }
}

#希尔排序
对插入排序的优化

#归并排序
基于分治
时间复杂度O(NlogN)
原问题：把数组排序
子问题：把数组前一半，后一半分别排序，然后在合并
public static void mergeSort(int[] arr, int l, int r) {
    if ( l>=r) return;
    int mid = (l + r ) / 2;
    mergeSort(arr, 1, mid);
    mergeSort(arr, mid+1, r);
    merge(arr, 1, mid, r); //合并2个有序数组

}

#快速排序
从数组中选取中轴元素pivot
将小元素放在pivot左边，大元素放在右边
然后分别对左边和右边的子数组进行快排

快速排序和归并排序具有相似性

#非比较类排序

计数排序
输入必须是确定范围的整数，将输入的数据作为key存储在额外的数组中

桶排序
桶排序假设输入数据服从均匀分布，将数据分到有限数量的桶内，每个桶再分别排序

基数排序
把数据切割成一位数字，从低位到高位对每一位分别进行计数排序
时间复杂度

